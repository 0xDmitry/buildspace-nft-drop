[{"/home/runner/nft-drop-starter-project/src/index.js":"1","/home/runner/nft-drop-starter-project/src/App.js":"2","/home/runner/nft-drop-starter-project/src/CandyMachine/index.js":"3","/home/runner/nft-drop-starter-project/src/CandyMachine/connection.js":"4","/home/runner/nft-drop-starter-project/src/CandyMachine/helpers.js":"5","/home/runner/nft-drop-starter-project/src/CountdownTimer/index.js":"6"},{"size":219,"mtime":1644275160733,"results":"7","hashOfConfig":"8"},{"size":2449,"mtime":1644275161129,"results":"9","hashOfConfig":"8"},{"size":13055,"mtime":1644275161129,"results":"10","hashOfConfig":"8"},{"size":12897,"mtime":1644275161129,"results":"11","hashOfConfig":"8"},{"size":3146,"mtime":1644275161129,"results":"12","hashOfConfig":"8"},{"size":1592,"mtime":1644275160749,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"eg3kag",{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},"/home/runner/nft-drop-starter-project/src/index.js",[],"/home/runner/nft-drop-starter-project/src/App.js",[],"/home/runner/nft-drop-starter-project/src/CandyMachine/index.js",["28"],"import React, { useEffect, useState } from \"react\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { Program, Provider, web3 } from \"@project-serum/anchor\";\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { sendTransactions } from \"./connection\";\nimport \"./CandyMachine.css\";\nimport {\n  candyMachineProgram,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  CIVIC,\n} from \"./helpers\";\nimport CountdownTimer from \"../CountdownTimer\";\n\nconst { SystemProgram } = web3;\nconst opts = {\n  preflightCommitment: \"processed\",\n};\n\nconst CandyMachine = ({ walletAddress }) => {\n  // State\n\n  const [candyMachine, setCandyMachine] = useState(null);\n\n  // Actions\n\n  const mintToken = async () => {\n    const mint = web3.Keypair.generate();\n\n    const userTokenAccountAddress = (\n      await getAtaForMint(mint.publicKey, walletAddress.publicKey)\n    )[0];\n\n    const userPayingAccountAddress = candyMachine.state.tokenMint\n      ? (\n          await getAtaForMint(\n            candyMachine.state.tokenMint,\n            walletAddress.publicKey\n          )\n        )[0]\n      : walletAddress.publicKey;\n\n    const candyMachineAddress = candyMachine.id;\n    const remainingAccounts = [];\n    const signers = [mint];\n    const cleanupInstructions = [];\n    const instructions = [\n      web3.SystemProgram.createAccount({\n        fromPubkey: walletAddress.publicKey,\n        newAccountPubkey: mint.publicKey,\n        space: MintLayout.span,\n        lamports:\n          await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n            MintLayout.span\n          ),\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        0,\n        walletAddress.publicKey,\n        walletAddress.publicKey\n      ),\n      createAssociatedTokenAccountInstruction(\n        userTokenAccountAddress,\n        walletAddress.publicKey,\n        walletAddress.publicKey,\n        mint.publicKey\n      ),\n      Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        userTokenAccountAddress,\n        walletAddress.publicKey,\n        [],\n        1\n      ),\n    ];\n\n    if (candyMachine.state.gatekeeper) {\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkToken(\n            walletAddress.publicKey,\n            candyMachine.state.gatekeeper.gatekeeperNetwork\n          )\n        )[0],\n        isWritable: true,\n        isSigner: false,\n      });\n      if (candyMachine.state.gatekeeper.expireOnUse) {\n        remainingAccounts.push({\n          pubkey: CIVIC,\n          isWritable: false,\n          isSigner: false,\n        });\n        remainingAccounts.push({\n          pubkey: (\n            await getNetworkExpire(\n              candyMachine.state.gatekeeper.gatekeeperNetwork\n            )\n          )[0],\n          isWritable: false,\n          isSigner: false,\n        });\n      }\n    }\n    if (candyMachine.state.whitelistMintSettings) {\n      const mint = new web3.PublicKey(\n        candyMachine.state.whitelistMintSettings.mint\n      );\n\n      const whitelistToken = (\n        await getAtaForMint(mint, walletAddress.publicKey)\n      )[0];\n      remainingAccounts.push({\n        pubkey: whitelistToken,\n        isWritable: true,\n        isSigner: false,\n      });\n\n      if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n        const whitelistBurnAuthority = web3.Keypair.generate();\n\n        remainingAccounts.push({\n          pubkey: mint,\n          isWritable: true,\n          isSigner: false,\n        });\n        remainingAccounts.push({\n          pubkey: whitelistBurnAuthority.publicKey,\n          isWritable: false,\n          isSigner: true,\n        });\n        signers.push(whitelistBurnAuthority);\n        const exists =\n          await candyMachine.program.provider.connection.getAccountInfo(\n            whitelistToken\n          );\n        if (exists) {\n          instructions.push(\n            Token.createApproveInstruction(\n              TOKEN_PROGRAM_ID,\n              whitelistToken,\n              whitelistBurnAuthority.publicKey,\n              walletAddress.publicKey,\n              [],\n              1\n            )\n          );\n          cleanupInstructions.push(\n            Token.createRevokeInstruction(\n              TOKEN_PROGRAM_ID,\n              whitelistToken,\n              walletAddress.publicKey,\n              []\n            )\n          );\n        }\n      }\n    }\n\n    if (candyMachine.state.tokenMint) {\n      const transferAuthority = web3.Keypair.generate();\n\n      signers.push(transferAuthority);\n      remainingAccounts.push({\n        pubkey: userPayingAccountAddress,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: transferAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n\n      instructions.push(\n        Token.createApproveInstruction(\n          TOKEN_PROGRAM_ID,\n          userPayingAccountAddress,\n          transferAuthority.publicKey,\n          walletAddress.publicKey,\n          [],\n          candyMachine.state.price.toNumber()\n        )\n      );\n      cleanupInstructions.push(\n        Token.createRevokeInstruction(\n          TOKEN_PROGRAM_ID,\n          userPayingAccountAddress,\n          walletAddress.publicKey,\n          []\n        )\n      );\n    }\n    const metadataAddress = await getMetadata(mint.publicKey);\n    const masterEdition = await getMasterEdition(mint.publicKey);\n\n    const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n      candyMachineAddress\n    );\n\n    instructions.push(\n      await candyMachine.program.instruction.mintNft(creatorBump, {\n        accounts: {\n          candyMachine: candyMachineAddress,\n          candyMachineCreator,\n          payer: walletAddress.publicKey,\n          wallet: candyMachine.state.treasury,\n          mint: mint.publicKey,\n          metadata: metadataAddress,\n          masterEdition,\n          mintAuthority: walletAddress.publicKey,\n          updateAuthority: walletAddress.publicKey,\n          tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: SystemProgram.programId,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n          clock: web3.SYSVAR_CLOCK_PUBKEY,\n          recentBlockhashes: web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          instructionSysvarAccount: web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n        },\n        remainingAccounts:\n          remainingAccounts.length > 0 ? remainingAccounts : undefined,\n      })\n    );\n\n    try {\n      return (\n        await sendTransactions(\n          candyMachine.program.provider.connection,\n          candyMachine.program.provider.wallet,\n          [instructions, cleanupInstructions],\n          [signers, []]\n        )\n      ).txs.map((t) => t.txid);\n    } catch (e) {\n      console.log(e);\n    }\n    return [];\n  };\n\n  const createAssociatedTokenAccountInstruction = (\n    associatedTokenAddress,\n    payer,\n    walletAddress,\n    splTokenMintAddress\n  ) => {\n    const keys = [\n      { pubkey: payer, isSigner: true, isWritable: true },\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n      {\n        pubkey: web3.SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n      {\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    return new web3.TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    });\n  };\n\n  const getMetadata = async (mint) => {\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from(\"metadata\"),\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n          mint.toBuffer(),\n        ],\n        TOKEN_METADATA_PROGRAM_ID\n      )\n    )[0];\n  };\n\n  const getMasterEdition = async (mint) => {\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from(\"metadata\"),\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n          mint.toBuffer(),\n          Buffer.from(\"edition\"),\n        ],\n        TOKEN_METADATA_PROGRAM_ID\n      )\n    )[0];\n  };\n\n  const getCandyMachineCreator = async (candyMachine) => {\n    const candyMachineID = new PublicKey(candyMachine);\n    return await web3.PublicKey.findProgramAddress(\n      [Buffer.from(\"candy_machine\"), candyMachineID.toBuffer()],\n      candyMachineProgram\n    );\n  };\n\n  // Effects\n\n  useEffect(() => {\n    getCandyMachineState();\n  }, []);\n\n  const getCandyMachineState = async () => {\n    const provider = getProvider();\n\n    // Get metadata about your deployed candy machine program\n    const idl = await Program.fetchIdl(candyMachineProgram, provider);\n\n    // Create a program that you can call\n    const program = new Program(idl, candyMachineProgram, provider);\n\n    // Fetch the metadata from your candy machine\n    const candyMachine = await program.account.candyMachine.fetch(\n      process.env.REACT_APP_CANDY_MACHINE_ID\n    );\n\n    // Parse out all our metadata and log it out\n    const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\n    const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\n    const goLiveData = candyMachine.data.goLiveDate.toNumber();\n    const presale =\n      candyMachine.data.whitelistMintSettings &&\n      candyMachine.data.whitelistMintSettings.presale &&\n      (!candyMachine.data.goLiveDate ||\n        candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n\n    // We will be using this later in our UI so let's generate this now\n    const goLiveDateTimeString = `${new Date(\n      goLiveData * 1000\n    ).toLocaleDateString()} @ ${new Date(\n      goLiveData * 1000\n    ).toLocaleTimeString()}`;\n\n    setCandyMachine({\n      id: process.env.REACT_APP_CANDY_MACHINE_ID,\n      program,\n      state: {\n        itemsAvailable,\n        itemsRedeemed,\n        itemsRemaining,\n        goLiveData,\n        goLiveDateTimeString,\n        isSoldOut: itemsRemaining === 0,\n        isActive:\n          (presale ||\n            candyMachine.data.goLiveDate.toNumber() <\n              new Date().getTime() / 1000) &&\n          (candyMachine.endSettings\n            ? candyMachine.endSettings.endSettingType.date\n              ? candyMachine.endSettings.number.toNumber() >\n                new Date().getTime() / 1000\n              : itemsRedeemed < candyMachine.endSettings.number.toNumber()\n            : true),\n        isPresale: presale,\n        goLiveDate: candyMachine.data.goLiveDate,\n        treasury: candyMachine.wallet,\n        tokenMint: candyMachine.tokenMint,\n        gatekeeper: candyMachine.data.gatekeeper,\n        endSettings: candyMachine.data.endSettings,\n        whitelistMintSettings: candyMachine.data.whitelistMintSettings,\n        hiddenSettings: candyMachine.data.hiddenSettings,\n        price: candyMachine.data.price,\n      },\n    });\n\n    console.log({\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      goLiveData,\n      goLiveDateTimeString,\n      presale,\n    });\n  };\n\n  const getProvider = () => {\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\n    // Create a new connection object\n    const connection = new Connection(rpcHost);\n\n    // Create a new Solana provider object\n    const provider = new Provider(\n      connection,\n      window.solana,\n      opts.preflightCommitment\n    );\n\n    return provider;\n  };\n\n  // Render\n\n  const renderDropTimer = () => {\n    // Get the current date and dropDate in a JavaScript Date object\n    const currentDate = new Date();\n    const dropDate = new Date(candyMachine.state.goLiveData * 1000);\n\n    // If currentDate is before dropDate, render our Countdown component\n    if (currentDate < dropDate) {\n      console.log(\"Before drop date!\");\n      // Don't forget to pass over your dropDate!\n      return (\n        <CountdownTimer timerHeader=\"Drop Starting In\" dropDate={dropDate} />\n      );\n    }\n\n    // Else let's just return the current drop date\n    return <p>{`Drop Date: ${candyMachine.state.goLiveDateTimeString}`}</p>;\n  };\n\n  return (\n    candyMachine && (\n      <div className=\"machine-container\">\n        {renderDropTimer()}\n        <p>{`Items Minted: ${candyMachine.state.itemsRedeemed} / ${candyMachine.state.itemsAvailable}`}</p>\n        {candyMachine.state.itemsRedeemed ===\n        candyMachine.state.itemsAvailable ? (\n          <p className=\"sub-text\">Sold Out 🙊</p>\n        ) : (\n          <button className=\"cta-button mint-button\" onClick={mintToken}>\n            Mint NFT\n          </button>\n        )}\n      </div>\n    )\n  );\n};\n\nexport default CandyMachine;\n","/home/runner/nft-drop-starter-project/src/CandyMachine/connection.js",[],"/home/runner/nft-drop-starter-project/src/CandyMachine/helpers.js",[],"/home/runner/nft-drop-starter-project/src/CountdownTimer/index.js",["29"],"import React, { useEffect, useState } from \"react\";\nimport \"./CountdownTimer.css\";\n\nconst CountdownTimer = ({ timerHeader, dropDate }) => {\n  // State\n\n  const [timerString, setTimerString] = useState(\"\");\n\n  // Effect\n\n  useEffect(() => {\n    console.log(\"Setting interval...\");\n\n    // Use setInterval to run this piece of code every second\n    const interval = setInterval(() => {\n      const currentDate = new Date().getTime();\n      const distance = dropDate - currentDate;\n\n      // Here it's as easy as doing some time math to get the different properties\n      const days = Math.floor(distance / (1000 * 60 * 60 * 24));\n      const hours = Math.floor(\n        (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\n      );\n      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\n      const seconds = Math.floor((distance % (1000 * 60)) / 1000);\n\n      // We have our desired output, set it in state!\n      setTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\n\n      // If our distance passes zero this means that it's drop time!\n      if (distance < 0) {\n        console.log(\"Clearing interval...\");\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    // Anytime our component unmounts let's clean up our interval\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n    };\n  }, []);\n\n  return (\n    <div className=\"timer-container\">\n      <p className=\"timer-header\">{timerHeader}</p>\n      {timerString && <p className=\"timer-value\">{`⏰ ${timerString}`}</p>}\n    </div>\n  );\n};\n\nexport default CountdownTimer;\n",{"ruleId":"30","severity":1,"message":"31","line":317,"column":6,"nodeType":"32","endLine":317,"endColumn":8,"suggestions":"33"},{"ruleId":"30","severity":1,"message":"34","line":43,"column":6,"nodeType":"32","endLine":43,"endColumn":8,"suggestions":"35"},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getCandyMachineState'. Either include it or remove the dependency array.","ArrayExpression",["36"],"React Hook useEffect has a missing dependency: 'dropDate'. Either include it or remove the dependency array.",["37"],{"desc":"38","fix":"39"},{"desc":"40","fix":"41"},"Update the dependencies array to be: [getCandyMachineState]",{"range":"42","text":"43"},"Update the dependencies array to be: [dropDate]",{"range":"44","text":"45"},[8874,8876],"[getCandyMachineState]",[1357,1359],"[dropDate]"]